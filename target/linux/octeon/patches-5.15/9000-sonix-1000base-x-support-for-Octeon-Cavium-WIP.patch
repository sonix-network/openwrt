From cde06dd32cf51c133ce3b6f0184b0bb3d41eb47d Mon Sep 17 00:00:00 2001
From: Christian Svensson <blue@cmd.nu>
Date: Wed, 21 Jun 2023 11:56:21 +0200
Subject: [PATCH 9000/9001] sonix: 1000base-x support for Octeon Cavium [WIP]

This patch needs cleaning up.

Allows setting 1000base-x instead of SGMII using device-tree attributes.
---
 arch/mips/cavium-octeon/executive/Makefile    |    2 +-
 .../cavium-octeon/executive/cvmx-helper-cfg.c | 1183 +++++++++++++++++
 .../executive/cvmx-helper-sgmii.c             |   95 +-
 .../mips/include/asm/octeon/cvmx-helper-cfg.h |  793 +++++++++++
 .../include/asm/octeon/cvmx-helper-util.h     |   33 +
 drivers/staging/octeon/Makefile               |    2 +
 drivers/staging/octeon/ethernet.c             |   75 ++
 drivers/staging/octeon/octeon-ethernet.h      |    1 +
 8 files changed, 2115 insertions(+), 69 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-helper-cfg.h

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index 50b427879465..2bff7ee3af30 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -14,6 +14,6 @@ obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o \
 	cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
 	cvmx-helper-rgmii.o cvmx-helper-sgmii.o cvmx-helper-npi.o \
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o \
-	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
+	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o cvmx-helper-cfg.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o cvmx-boot-vector.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
new file mode 100644
index 000000000000..0cb4193160f9
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -0,0 +1,1183 @@
+/***********************license start***************
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Helper Functions for the Configuration Framework
+ *
+ * <hr>$Revision: 0 $<hr>
+ */
+
+#include <linux/export.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-board.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+
+//int cvmx_npi_max_pknds;
+static bool port_cfg_data_initialized = false;
+
+struct cvmx_cfg_port_param cvmx_cfg_port[CVMX_MAX_NODES][CVMX_HELPER_MAX_IFACE][CVMX_HELPER_CFG_MAX_PORT_PER_IFACE];
+
+static void cvmx_init_port_cfg(void);
+
+#if 0
+/*
+ * Indexed by the pko_port number
+ */
+static int __cvmx_cfg_pko_highest_queue;
+struct cvmx_cfg_pko_port_param cvmx_pko_queue_table [CVMX_HELPER_CFG_MAX_PKO_PORT] =
+{[0 ... CVMX_HELPER_CFG_MAX_PKO_PORT - 1] = {CVMX_HELPER_CFG_INVALID_VALUE,CVMX_HELPER_CFG_INVALID_VALUE}};
+
+cvmx_user_static_pko_queue_config_t __cvmx_pko_queue_static_config;
+
+struct cvmx_cfg_pko_port_map cvmx_cfg_pko_port_map[CVMX_HELPER_CFG_MAX_PKO_PORT] =
+	{[0 ... CVMX_HELPER_CFG_MAX_PKO_PORT - 1] = {CVMX_HELPER_CFG_INVALID_VALUE,CVMX_HELPER_CFG_INVALID_VALUE,
+						     CVMX_HELPER_CFG_INVALID_VALUE}};
+
+/*
+ * This array assists translation from ipd_port to pko_port.
+ * The ``16'' is the rounded value for the 3rd 4-bit value of
+ * ipd_port, used to differentiate ``interfaces.''
+ */
+static struct cvmx_cfg_pko_port_pair ipd2pko_port_cache[16]
+    [CVMX_HELPER_CFG_MAX_PORT_PER_IFACE] =
+	{[0 ... 15] = {[0 ... CVMX_HELPER_CFG_MAX_PORT_PER_IFACE - 1] =
+		       { CVMX_HELPER_CFG_INVALID_VALUE,	CVMX_HELPER_CFG_INVALID_VALUE}}};
+
+
+/*
+ * Options
+ *
+ * Each array-elem's intial value is also the option's default value.
+ */
+static uint64_t cvmx_cfg_opts[CVMX_HELPER_CFG_OPT_MAX] = {[0 ... CVMX_HELPER_CFG_OPT_MAX - 1] = 1 };
+
+/*
+ * MISC
+ */
+static int cvmx_cfg_max_pko_engines;	/* # of PKO DMA engines
+							   allocated */
+static int cvmx_pko_queue_alloc(uint64_t port, int count);
+static const int dbg = 0;
+
+int __cvmx_helper_cfg_pknd(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int pkind;
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+
+	pkind = cvmx_cfg_port[xi.node][xi.interface][index].ccpp_pknd;
+	return pkind;
+}
+
+int __cvmx_helper_cfg_bpid(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+
+	return cvmx_cfg_port[xi.node][xi.interface][index].ccpp_bpid;
+}
+
+int __cvmx_helper_cfg_pko_port_base(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+
+	return cvmx_cfg_port[xi.node][xi.interface][index].ccpp_pko_port_base;
+}
+
+int __cvmx_helper_cfg_pko_port_num(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+
+	return cvmx_cfg_port[xi.node][xi.interface][index].ccpp_pko_num_ports;
+}
+
+int __cvmx_helper_cfg_pko_queue_num(int pko_port)
+{
+	return cvmx_pko_queue_table[pko_port].ccppp_num_queues;
+}
+
+int __cvmx_helper_cfg_pko_queue_base(int pko_port)
+{
+	return cvmx_pko_queue_table[pko_port].ccppp_queue_base;
+}
+
+int __cvmx_helper_cfg_pko_max_queue(void)
+{
+	return __cvmx_cfg_pko_highest_queue;
+}
+
+int __cvmx_helper_cfg_pko_max_engine(void)
+{
+	return cvmx_cfg_max_pko_engines;
+}
+
+int cvmx_helper_cfg_opt_set(cvmx_helper_cfg_option_t opt, uint64_t val)
+{
+	if (opt >= CVMX_HELPER_CFG_OPT_MAX)
+		return -1;
+
+	cvmx_cfg_opts[opt] = val;
+
+	return 0;
+}
+
+uint64_t cvmx_helper_cfg_opt_get(cvmx_helper_cfg_option_t opt)
+{
+	if (opt >= CVMX_HELPER_CFG_OPT_MAX)
+		return (uint64_t) CVMX_HELPER_CFG_INVALID_VALUE;
+
+	return cvmx_cfg_opts[opt];
+}
+
+/*
+ * initialize the queue allocation list. the existing static allocation result
+ * is used as a starting point to ensure backward compatibility.
+ *
+ * @return  0 on success
+ *         -1 on failure
+ */
+int cvmx_pko_queue_grp_alloc(uint64_t start, uint64_t end, uint64_t count)
+{
+	uint64_t port;
+	int ret_val;
+	for (port = start; port < end; port++) {
+		ret_val = cvmx_pko_queue_alloc(port, count);
+		if (ret_val == -1)
+		{
+			cvmx_printf("ERROR: %sL Failed to allocate queue "
+				"for port=%d count=%d\n",
+				__func__, (int) port, (int) count);
+			return ret_val;
+		}
+	}
+	return 0;
+}
+
+int cvmx_pko_queue_init_from_cvmx_config_non_pknd(void)
+{
+	int ret_val = -1;
+	uint64_t count, start, end;
+
+	start = 0;
+	end   = __cvmx_pko_queue_static_config.non_pknd.pko_ports_per_interface[0];
+	count = __cvmx_pko_queue_static_config.non_pknd. pko_queues_per_port_interface[0];
+	cvmx_pko_queue_grp_alloc(start,end,count);
+
+	start = 16;
+	end = start + __cvmx_pko_queue_static_config.non_pknd.pko_ports_per_interface[1];
+	count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_interface[1];
+	ret_val = cvmx_pko_queue_grp_alloc(start,end,count);
+	if (ret_val != 0)
+		return -1;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		/* Interface 4: AGL, PKO port 24 only, DPI 32-35 */
+		start = 24;
+		end = start + 1;
+		count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_interface[4];
+		ret_val = cvmx_pko_queue_grp_alloc(start,end,count);
+
+		if (ret_val != 0)
+			return -1;
+		end = 32;	/* DPI first PKO poty */
+	}
+
+	start = end; end = 36 ; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_pci;
+	cvmx_pko_queue_grp_alloc(start,end,count);
+	if (ret_val != 0)
+		return -1;
+
+	start = end; end = 40; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_loop;
+	cvmx_pko_queue_grp_alloc(start,end,count);
+	if (ret_val != 0)
+		return -1;
+
+	start = end; end = 42; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_srio[0];
+	cvmx_pko_queue_grp_alloc(start, end, count);
+	if (ret_val != 0)
+		return -1;
+
+	start = end; end = 44; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_srio[1];
+	cvmx_pko_queue_grp_alloc(start, end, count);
+	if (ret_val != 0)
+		return -1;
+
+	start = end; end = 46; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_srio[2];
+	cvmx_pko_queue_grp_alloc(start,end, count);
+	if (ret_val != 0)
+		return -1;
+
+	start = end; end = 48; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_srio[3];
+	cvmx_pko_queue_grp_alloc(start, end, count);
+	if (ret_val != 0)
+		return -1;
+	return 0;
+}
+
+static int queue_range_init = 0;
+
+int init_cvmx_pko_que_range(void)
+{
+	int rv = 0;
+
+	if (queue_range_init)
+		return 0;
+	queue_range_init = 1;
+	rv = cvmx_create_global_resource_range(CVMX_GR_TAG_PKO_QUEUES, CVMX_HELPER_CFG_MAX_PKO_QUEUES);
+	if (rv!=0) {
+		cvmx_printf("ERROR: %s: Failed to initalize pko queues range\n",
+			__func__);
+	}
+	return rv;
+}
+
+
+/*
+ * get a block of "count" queues for "port"
+ *
+ * @param  port   the port for which the queues are requested
+ * @param  count  the number of queues requested
+ *
+ * @return  0 on success
+ *         -1 on failure
+ */
+static int cvmx_pko_queue_alloc(uint64_t port, int count)
+{
+    int ret_val = -1;
+    int highest_queue;
+    const int debug = 0;
+
+    init_cvmx_pko_que_range();
+
+    if (cvmx_pko_queue_table[port].ccppp_num_queues == count)
+	    return cvmx_pko_queue_table[port].ccppp_queue_base;
+
+    if (cvmx_pko_queue_table[port].ccppp_num_queues > 0) {
+	    cvmx_printf("WARNING: %s port=%d already %d queues\n",
+		__func__, (int)port,
+		(int)cvmx_pko_queue_table[port].ccppp_num_queues);
+	return -1;
+    }
+
+    if (port >= CVMX_HELPER_CFG_MAX_PKO_QUEUES) {
+	    cvmx_printf("ERROR: %s port=%d > %d\n", __func__,
+		(int) port, CVMX_HELPER_CFG_MAX_PKO_QUEUES );
+	    return -1;
+    }
+
+    ret_val = cvmx_allocate_global_resource_range(CVMX_GR_TAG_PKO_QUEUES,
+	port, count, 1);
+
+    if (debug)
+	    cvmx_dprintf("%s: pko_e_port=%i q_base=%i q_count=%i \n",
+		__func__, (int) port, ret_val, (int) count);
+
+    if (ret_val == -1)
+        return ret_val;
+    cvmx_pko_queue_table[port].ccppp_queue_base = ret_val;
+    cvmx_pko_queue_table[port].ccppp_num_queues = count;
+
+    highest_queue = ret_val + count - 1;
+    if (highest_queue > __cvmx_cfg_pko_highest_queue)
+	    __cvmx_cfg_pko_highest_queue = highest_queue;
+    return 0;
+}
+
+/*
+ * return the queues for "port"
+ *
+ * @param  port   the port for which the queues are returned
+ *
+ * @return  0 on success
+ *         -1 on failure
+ */
+int cvmx_pko_queue_free(uint64_t port)
+{
+    int ret_val = -1;
+
+    init_cvmx_pko_que_range();
+    if (port >= CVMX_HELPER_CFG_MAX_PKO_QUEUES) {
+	    cvmx_dprintf("ERROR: %s port=%d > %d", __FUNCTION__,
+			 (int) port, CVMX_HELPER_CFG_MAX_PKO_QUEUES);
+	    return -1;
+    }
+
+    ret_val = cvmx_free_global_resource_range_with_base(CVMX_GR_TAG_PKO_QUEUES,
+							cvmx_pko_queue_table[port].ccppp_queue_base,
+							cvmx_pko_queue_table[port].ccppp_num_queues);
+    if (ret_val != 0)
+        return ret_val;
+
+    cvmx_pko_queue_table[port].ccppp_num_queues = 0;
+    cvmx_pko_queue_table[port].ccppp_queue_base = CVMX_HELPER_CFG_INVALID_VALUE;
+    ret_val = 0;
+    return ret_val;
+}
+
+void cvmx_pko_queue_free_all(void)
+{
+	int i;
+
+	for(i=0; i< CVMX_HELPER_CFG_MAX_PKO_PORT; i++)
+		if (cvmx_pko_queue_table[i].ccppp_queue_base != CVMX_HELPER_CFG_INVALID_VALUE)
+			cvmx_pko_queue_free(i);
+	//cvmx_range_show(pko_queue_range);
+}
+
+void cvmx_pko_queue_show()
+{
+	int i;
+
+	cvmx_show_global_resource_range(CVMX_GR_TAG_PKO_QUEUES);
+	for(i=0; i< CVMX_HELPER_CFG_MAX_PKO_PORT; i++)
+		if (cvmx_pko_queue_table[i].ccppp_queue_base != CVMX_HELPER_CFG_INVALID_VALUE)
+			cvmx_dprintf("port=%d que_base=%d que_num=%d \n", i,
+				     (int) cvmx_pko_queue_table[i].ccppp_queue_base,
+				     (int) cvmx_pko_queue_table[i].ccppp_num_queues);
+}
+
+EXPORT_SYMBOL(__cvmx_helper_cfg_pknd);
+EXPORT_SYMBOL(__cvmx_helper_cfg_bpid);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_base);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_num);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_queue_base);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_queue_num);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_max_queue);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_interface);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_index);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_port_eid);
+EXPORT_SYMBOL(__cvmx_helper_cfg_pko_max_engine);
+EXPORT_SYMBOL(cvmx_helper_cfg_opt_get);
+EXPORT_SYMBOL(cvmx_helper_cfg_opt_set);
+EXPORT_SYMBOL(cvmx_helper_cfg_ipd2pko_port_base);
+EXPORT_SYMBOL(cvmx_helper_cfg_ipd2pko_port_num);
+EXPORT_SYMBOL(cvmx_pko_queue_free_all);
+
+
+void cvmx_helper_cfg_show_cfg(void)
+{
+	int i, j;
+
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		cvmx_dprintf("cvmx_helper_cfg_show_cfg: interface%d mode %10s nports%4d\n", i,
+			     cvmx_helper_interface_mode_to_string(cvmx_helper_interface_get_mode(i)),
+			     cvmx_helper_interface_enumerate(i));
+
+		for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+			cvmx_dprintf("\tpknd[%i][%d]%d", i, j, __cvmx_helper_cfg_pknd(i, j));
+			cvmx_dprintf(" pko_port_base[%i][%d]%d", i, j, __cvmx_helper_cfg_pko_port_base(i, j));
+			cvmx_dprintf(" pko_port_num[%i][%d]%d\n", i, j, __cvmx_helper_cfg_pko_port_num(i, j));
+		}
+	}
+
+	for (i = 0; i < CVMX_HELPER_CFG_MAX_PKO_PORT; i++) {
+		if (__cvmx_helper_cfg_pko_queue_base(i) != CVMX_HELPER_CFG_INVALID_VALUE) {
+			cvmx_dprintf("cvmx_helper_cfg_show_cfg: pko_port%d qbase%d nqueues%d "
+				     "interface%d index%d\n", i,
+				     __cvmx_helper_cfg_pko_queue_base(i),
+				     __cvmx_helper_cfg_pko_queue_num(i), __cvmx_helper_cfg_pko_port_interface(i),
+				     __cvmx_helper_cfg_pko_port_index(i));
+		}
+	}
+}
+
+/*
+ * initialize cvmx_cfg_pko_port_map
+ */
+void cvmx_helper_cfg_init_pko_port_map(void)
+{
+	int i, j, k;
+	int pko_eid;
+	int pko_port_base, pko_port_max;
+	cvmx_helper_interface_mode_t mode;
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	/*
+	 * one pko_eid is allocated to each port except for ILK, NPI, and
+	 * LOOP. Each of the three has one eid.
+	 */
+	pko_eid = 0;
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		mode = cvmx_helper_interface_get_mode(i);
+		for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+			pko_port_base = cvmx_cfg_port[0][i][j].ccpp_pko_port_base;
+			pko_port_max = pko_port_base + cvmx_cfg_port[0][i][j].ccpp_pko_num_ports;
+			if (!octeon_has_feature(OCTEON_FEATURE_PKO3)) {
+				cvmx_helper_cfg_assert(pko_port_base != CVMX_HELPER_CFG_INVALID_VALUE);
+				cvmx_helper_cfg_assert(pko_port_max >= pko_port_base);
+			}
+			for (k = pko_port_base; k < pko_port_max; k++) {
+				cvmx_cfg_pko_port_map[k].ccppl_interface = i;
+				cvmx_cfg_pko_port_map[k].ccppl_index = j;
+				cvmx_cfg_pko_port_map[k].ccppl_eid = pko_eid;
+			}
+
+			if (!(mode == CVMX_HELPER_INTERFACE_MODE_NPI || mode == CVMX_HELPER_INTERFACE_MODE_LOOP))
+					pko_eid++;
+		}
+
+		if (mode == CVMX_HELPER_INTERFACE_MODE_NPI || mode == CVMX_HELPER_INTERFACE_MODE_LOOP)
+			pko_eid++;
+	}
+
+	/*
+	 * Legal pko_eids [0, 0x13] should not be exhausted.
+	 */
+	if (!octeon_has_feature(OCTEON_FEATURE_PKO3))
+		cvmx_helper_cfg_assert(pko_eid <= 0x14);
+
+	cvmx_cfg_max_pko_engines = pko_eid;
+}
+
+int __cvmx_helper_cfg_pko_port_interface(int pko_port)
+{
+	return cvmx_cfg_pko_port_map[pko_port].ccppl_interface;
+}
+
+int __cvmx_helper_cfg_pko_port_index(int pko_port)
+{
+	return cvmx_cfg_pko_port_map[pko_port].ccppl_index;
+}
+
+int __cvmx_helper_cfg_pko_port_eid(int pko_port)
+{
+	return cvmx_cfg_pko_port_map[pko_port].ccppl_eid;
+}
+
+#define IPD2PKO_CACHE_Y(ipd_port)	(ipd_port) >> 8
+#define IPD2PKO_CACHE_X(ipd_port)	(ipd_port) & 0xff
+
+static inline int __cvmx_helper_cfg_ipd2pko_cachex(int ipd_port)
+{
+	int ipd_x = IPD2PKO_CACHE_X(ipd_port);
+	if (ipd_port & 0x800)
+		ipd_x = (ipd_x >> 4) & 3;
+	return ipd_x;
+}
+
+/*
+ * ipd_port to pko_port translation cache
+ */
+int __cvmx_helper_cfg_init_ipd2pko_cache(void)
+{
+	int i, j, n;
+	int ipd_y, ipd_x, ipd_port;
+
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		n = cvmx_helper_interface_enumerate(i);
+
+		for (j = 0; j < n; j++) {
+			ipd_port = cvmx_helper_get_ipd_port(i, j);
+			ipd_y = IPD2PKO_CACHE_Y(ipd_port);
+			ipd_x = __cvmx_helper_cfg_ipd2pko_cachex(ipd_port);
+			ipd2pko_port_cache[ipd_y]
+			    [ipd_x] = (struct cvmx_cfg_pko_port_pair) {
+			__cvmx_helper_cfg_pko_port_base(i, j), __cvmx_helper_cfg_pko_port_num(i, j)};
+		}
+	}
+
+	return 0;
+}
+
+int cvmx_helper_cfg_ipd2pko_port_base(int ipd_port)
+{
+	int ipd_y, ipd_x;
+
+	/* Internal PKO ports are not present in PKO3 */
+	if(octeon_has_feature(OCTEON_FEATURE_PKI))
+		return ipd_port;
+
+	ipd_y = IPD2PKO_CACHE_Y(ipd_port);
+	ipd_x = __cvmx_helper_cfg_ipd2pko_cachex(ipd_port);
+
+	return ipd2pko_port_cache[ipd_y][ipd_x].ccppp_base_port;
+}
+
+int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port)
+{
+	int ipd_y, ipd_x;
+
+	ipd_y = IPD2PKO_CACHE_Y(ipd_port);
+	ipd_x = __cvmx_helper_cfg_ipd2pko_cachex(ipd_port);
+
+	return ipd2pko_port_cache[ipd_y][ipd_x].ccppp_nports;
+}
+
+/**
+ * Return the number of queues to be assigned to this pko_port
+ *
+ * @param pko_port
+ * @return the number of queues for this pko_port
+ *
+ */
+static int cvmx_helper_cfg_dft_nqueues(int pko_port)
+{
+	cvmx_helper_interface_mode_t mode;
+	int interface;
+	int n;
+	int ret;
+
+	interface = __cvmx_helper_cfg_pko_port_interface(pko_port);
+	mode = cvmx_helper_interface_get_mode(interface);
+
+	n = NUM_ELEMENTS(__cvmx_pko_queue_static_config.pknd.pko_cfg_iface);
+
+	if (mode == CVMX_HELPER_INTERFACE_MODE_LOOP) {
+		ret =  __cvmx_pko_queue_static_config.pknd.pko_cfg_loop.queues_per_port;
+	}
+	else if (mode == CVMX_HELPER_INTERFACE_MODE_NPI) {
+		ret =  __cvmx_pko_queue_static_config.pknd.pko_cfg_npi.queues_per_port;
+	}
+
+
+	else if ((interface >= 0) && (interface < n) )  {
+		ret = __cvmx_pko_queue_static_config.pknd.pko_cfg_iface[interface].queues_per_port;
+	} else {
+		/* Should never be called */
+		ret = 1;
+	}
+	/* Override for sanity in case of empty static config table */
+	if (ret == 0)
+		ret = 1;
+	return ret;
+}
+
+static int cvmx_helper_cfg_init_pko_iports_and_queues_using_static_config(void)
+{
+	int pko_port_base = 0 ;
+	int cvmx_cfg_default_pko_nports = 1;
+	int i, j, n, k;
+	int rv = 0;
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+
+	/* When not using config file, each port is assigned one internal pko port*/
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+		n = cvmx_helper_interface_enumerate(i);
+		for (j = 0; j < n; j++) {
+			cvmx_cfg_port[0][i][j].ccpp_pko_port_base = pko_port_base;
+			cvmx_cfg_port[0][i][j].ccpp_pko_num_ports = cvmx_cfg_default_pko_nports;
+			/* Initalize interface early here so that the
+			   cvmx_helper_cfg_dft_nqueues() below
+			   can get the interface number corresponding to the pko port */
+			for (k = pko_port_base; k < pko_port_base + cvmx_cfg_default_pko_nports; k++) {
+				cvmx_cfg_pko_port_map[k].ccppl_interface = i;
+			}
+			pko_port_base += cvmx_cfg_default_pko_nports;
+		}
+	}
+	cvmx_helper_cfg_assert(pko_port_base <= CVMX_HELPER_CFG_MAX_PKO_PORT);
+
+
+	/* Assigning queues per pko */
+	for (i = 0; i < pko_port_base; i++) {
+		int base;
+		n = cvmx_helper_cfg_dft_nqueues(i);
+		base = cvmx_pko_queue_alloc(i, n);
+		if (base == -1)  {
+			cvmx_printf("ERROR: %s: failed to alloc %d queues "
+				"for pko port=%d\n",
+				__func__, n, i);
+			rv = -1;
+		}
+	}
+	return rv;
+}
+#endif
+
+/**
+ * Returns if port is valid for a given interface
+ *
+ * @param xiface  interface to check
+ * @param index      port index in the interface
+ *
+ * @return status of the port present or not.
+ */
+int cvmx_helper_is_port_valid(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return  cvmx_cfg_port[xi.node][xi.interface][index].valid;
+}
+EXPORT_SYMBOL(cvmx_helper_is_port_valid);
+
+void cvmx_helper_set_port_valid(int xiface, int index, bool valid)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].valid = valid;
+}
+EXPORT_SYMBOL(cvmx_helper_set_port_valid);
+
+void cvmx_helper_set_mac_phy_mode(int xiface, int index, bool valid)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].sgmii_phy_mode = valid;
+}
+EXPORT_SYMBOL(cvmx_helper_set_mac_phy_mode);
+
+bool cvmx_helper_get_mac_phy_mode(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].sgmii_phy_mode;
+}
+EXPORT_SYMBOL(cvmx_helper_get_mac_phy_mode);
+
+void cvmx_helper_set_1000x_mode(int xiface, int index, bool valid)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].sgmii_1000x_mode = valid;
+}
+EXPORT_SYMBOL(cvmx_helper_set_1000x_mode);
+
+bool cvmx_helper_get_1000x_mode(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].sgmii_1000x_mode;
+}
+EXPORT_SYMBOL(cvmx_helper_get_1000x_mode);
+
+void cvmx_helper_set_agl_rx_clock_delay_bypass(int xiface, int index,
+					       bool valid)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].agl_rx_clk_delay_bypass = valid;
+}
+EXPORT_SYMBOL(cvmx_helper_set_agl_rx_clock_delay_bypass);
+
+bool cvmx_helper_get_agl_rx_clock_delay_bypass(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].agl_rx_clk_delay_bypass;
+}
+EXPORT_SYMBOL(cvmx_helper_get_agl_rx_clock_delay_bypass);
+
+void cvmx_helper_set_agl_rx_clock_skew(int xiface, int index, uint8_t value)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].agl_rx_clk_skew = value;
+}
+EXPORT_SYMBOL(cvmx_helper_set_agl_rx_clock_skew);
+
+uint8_t cvmx_helper_get_agl_rx_clock_skew(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].agl_rx_clk_skew;
+}
+EXPORT_SYMBOL(cvmx_helper_get_agl_rx_clock_skew);
+
+void cvmx_helper_set_agl_refclk_sel(int xiface, int index, uint8_t value)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].agl_refclk_sel = value;
+}
+EXPORT_SYMBOL(cvmx_helper_set_agl_refclk_sel);
+
+uint8_t cvmx_helper_get_agl_refclk_sel(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].agl_refclk_sel;
+}
+EXPORT_SYMBOL(cvmx_helper_get_agl_refclk_sel);
+
+void cvmx_helper_set_port_force_link_up(int xiface, int index, bool value)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].force_link_up = value;
+}
+EXPORT_SYMBOL(cvmx_helper_set_port_force_link_up);
+
+bool cvmx_helper_get_port_force_link_up(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].force_link_up;
+}
+EXPORT_SYMBOL(cvmx_helper_get_port_force_link_up);
+
+void cvmx_helper_set_port_phy_present(int xiface, int index, bool value)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].phy_present = value;
+}
+EXPORT_SYMBOL(cvmx_helper_set_port_phy_present);
+
+bool cvmx_helper_get_port_phy_present(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].phy_present;
+}
+EXPORT_SYMBOL(cvmx_helper_get_port_phy_present);
+
+#if 0
+int __cvmx_helper_init_port_valid(void)
+{
+	int i, j, node;
+	bool valid;
+	static void *fdt_addr = 0;
+	int rc;
+	cvmx_coremask_t *pcm = &cvmx_sysinfo_get()->core_mask;
+
+	if (fdt_addr == 0)
+		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
+						   (128*1024));
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
+		rc = __cvmx_helper_parse_bgx_dt(fdt_addr);
+		if (!rc)
+			rc = __cvmx_fdt_parse_vsc7224(fdt_addr);
+		if (!rc && octeon_has_feature(OCTEON_FEATURE_BGX_XCV))
+			rc = __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr);
+
+		/* Some ports are not in sequence, the device tree does not
+		 * clear them.
+		 *
+		 * Also clear any ports that are not defined in the device tree.
+		 * Apply this to each node.
+		 */
+		for (node = 0; node < CVMX_MAX_NODES; node++) {	
+			if (!cvmx_coremask_get64_node(pcm, node))
+				continue;
+			for (i = 0; i < CVMX_HELPER_MAX_GMX; i++) {
+				int j;
+				int xiface = cvmx_helper_node_interface_to_xiface(node, i
+);
+				for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+					cvmx_bgxx_cmrx_config_t cmr_config;
+					cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(j, i));
+					if ((cmr_config.s.lane_to_sds == 0xe4 &&
+					     cmr_config.s.lmac_type != 4 &&
+					     cmr_config.s.lmac_type != 1 &&
+					     cmr_config.s.lmac_type != 5) ||
+					     ((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
+						  (cvmx_helper_get_port_fdt_node_offset(xiface, j) ==
+						    CVMX_HELPER_CFG_INVALID_VALUE)))
+						cvmx_helper_set_port_valid(xiface, j, false);
+				}
+			}
+		}
+		return rc;
+	}
+
+	/* TODO: Update this to behave more like 78XX */
+	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+
+		int n = cvmx_helper_interface_enumerate(i);
+		for (j = 0; j < n; j++) {
+			int ipd_port = cvmx_helper_get_ipd_port(i, j);
+			valid = (__cvmx_helper_board_get_port_from_dt(fdt_addr,
+								      ipd_port) == 1);
+			cvmx_helper_set_port_valid(i, j, valid);
+		}
+	}
+	return 0;
+}
+
+typedef int (*cvmx_import_config_t)(void);
+cvmx_import_config_t cvmx_import_app_config = NULL;
+
+int __cvmx_helper_init_port_config_data_local(void)
+{
+	int rv = 0;
+	int dbg = 0;
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		if (cvmx_import_app_config) {
+			rv = (*cvmx_import_app_config)();
+			if (rv != 0) {
+				cvmx_dprintf("failed to import config\n");
+				return -1;
+			}
+		}
+
+		cvmx_helper_cfg_init_pko_port_map();
+		__cvmx_helper_cfg_init_ipd2pko_cache();
+	} else {
+		if (cvmx_import_app_config) {
+			rv = (*cvmx_import_app_config)();
+			if (rv != 0) {
+				cvmx_dprintf("failed to import config\n");
+				return -1;
+			}
+		}
+	}
+	if (dbg) {
+		cvmx_helper_cfg_show_cfg();
+		cvmx_pko_queue_show();
+	}
+	return rv;
+}
+
+/*
+ * This call is made from Linux octeon_ethernet driver
+ * to setup the PKO with a specific queue count and
+ * internal port count configuration.
+ */
+int cvmx_pko_alloc_iport_and_queues(int interface, int port, int port_cnt, int queue_cnt)
+{
+	int rv, p, port_start, cnt;
+
+	if (dbg)
+		cvmx_dprintf("%s: intf %d/%d pcnt %d qcnt %d\n",
+			__func__, interface, port, port_cnt, queue_cnt);
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		rv = cvmx_pko_internal_ports_alloc(interface, port, port_cnt);
+		if (rv < 0)  {
+			cvmx_printf("ERROR: %s: failed to allocate internal ports for"
+				     "interface=%d port=%d cnt=%d\n",
+				     __func__, interface, port,
+				     port_cnt);
+			return -1;
+		}
+		port_start =  __cvmx_helper_cfg_pko_port_base(interface, port);
+		cnt  = __cvmx_helper_cfg_pko_port_num(interface, port);
+	} else {
+		port_start = cvmx_helper_get_ipd_port(interface, port);
+		cnt = 1;
+	}
+
+	for (p = port_start; p < port_start + cnt; p++) {
+		rv = cvmx_pko_queue_alloc(p, queue_cnt);
+		if (rv < 0)  {
+			cvmx_printf("ERROR: %s: failed to allocate "
+				"queues for port=%d cnt=%d\n",
+				__func__, p, queue_cnt);
+			return -1;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_pko_alloc_iport_and_queues);
+#endif
+
+
+static void cvmx_init_port_cfg(void)
+{
+	int node, i, j;
+
+	if (port_cfg_data_initialized)
+		return;
+
+	for (node = 0; node < CVMX_MAX_NODES; node++) {
+		for (i = 0; i < CVMX_HELPER_MAX_IFACE; i++) {
+			for (j = 0; j < CVMX_HELPER_CFG_MAX_PORT_PER_IFACE; j++) {
+				struct cvmx_cfg_port_param *pcfg;
+
+				pcfg = &cvmx_cfg_port[node][i][j];
+				memset(pcfg, 0, sizeof(*pcfg));
+
+				pcfg->phy_info = NULL;
+				pcfg->ccpp_pknd = CVMX_HELPER_CFG_INVALID_VALUE;
+				pcfg->ccpp_bpid = CVMX_HELPER_CFG_INVALID_VALUE;
+				pcfg->ccpp_pko_port_base = CVMX_HELPER_CFG_INVALID_VALUE;
+				pcfg->ccpp_pko_num_ports = CVMX_HELPER_CFG_INVALID_VALUE;
+				pcfg->agl_rx_clk_skew = 0;
+				pcfg->valid = true;
+				pcfg->sgmii_phy_mode = false;
+				pcfg->sgmii_1000x_mode = false;
+				pcfg->agl_rx_clk_delay_bypass = false;
+				pcfg->force_link_up = false;
+				pcfg->disable_an = false;
+				pcfg->link_down_pwr_dn = false;
+				pcfg->phy_present = false;
+				pcfg->tx_clk_delay_bypass = false;
+				pcfg->rgmii_tx_clk_delay = 0;
+				pcfg->enable_fec = false;
+				pcfg->agl_refclk_sel = 0;
+				pcfg->sfp_of_offset = -1;
+				pcfg->vsc7224_chan = NULL;
+			}
+		}
+	}
+	port_cfg_data_initialized = true;
+}
+
+int __cvmx_helper_init_port_config_data(int node)
+{
+#if 0
+	int rv = 0;
+	int i, j, n;
+	int num_interfaces, interface;
+	int pknd = 0, bpid = 0;
+	const int use_static_config = 0;
+#endif
+
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+  return 0;
+
+#if 0
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		/* PKO3: only needs BPID, PKND to be setup,
+		 * while the rest of PKO3 init is done in cvmx-helper-pko3.c
+		 */
+		pknd = 0;
+		bpid = 0;
+		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+			int xiface = cvmx_helper_node_interface_to_xiface(node, i);
+			n = cvmx_helper_interface_enumerate(xiface);
+ 			if (cvmx_helper_interface_get_mode(xiface) != CVMX_HELPER_INTERFACE_MODE_NPI) {
+				for (j = 0; j < n; j++) {
+					struct cvmx_cfg_port_param *pcfg;
+					pcfg = &cvmx_cfg_port[node][i][j];
+					pcfg->ccpp_pknd = pknd++;
+					pcfg->ccpp_bpid = bpid++;
+				}
+			} else {
+				for (j = 0; j < n; j++) {
+
+					if (j == n/cvmx_npi_max_pknds) {
+						pknd++;
+						bpid++;
+					}
+					cvmx_cfg_port[node][i][j].ccpp_pknd = pknd;
+					cvmx_cfg_port[node][i][j].ccpp_bpid = bpid;
+				}
+				pknd++;
+				bpid++;
+			}
+		} /* for i=0 */
+		cvmx_helper_cfg_assert(pknd <= CVMX_HELPER_CFG_MAX_PIP_PKND);
+		cvmx_helper_cfg_assert(bpid <= CVMX_HELPER_CFG_MAX_PIP_BPID);
+	} else if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+
+		if (use_static_config)
+			cvmx_helper_cfg_init_pko_iports_and_queues_using_static_config();
+
+		/* Initialize pknd and bpid */
+		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
+                        n = cvmx_helper_interface_enumerate(i);
+			for (j = 0; j < n; j++) {
+				cvmx_cfg_port[0][i][j].ccpp_pknd = pknd++;
+				cvmx_cfg_port[0][i][j].ccpp_bpid = bpid++;
+			}
+                }
+		cvmx_helper_cfg_assert(pknd <= CVMX_HELPER_CFG_MAX_PIP_PKND);
+		cvmx_helper_cfg_assert(bpid <= CVMX_HELPER_CFG_MAX_PIP_BPID);
+	} else {
+		if (use_static_config)
+			cvmx_pko_queue_init_from_cvmx_config_non_pknd();
+	}
+
+	/* Remainder not used for PKO3 */
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
+		return 0;
+
+	/* init ports, queues which are not initialized */
+	num_interfaces = cvmx_helper_get_number_of_interfaces();
+	for (interface = 0; interface < num_interfaces; interface++) {
+		int num_ports = __cvmx_helper_early_ports_on_interface(interface);
+		int port, port_base, queue;
+
+		for (port = 0; port < num_ports; port++) {
+			bool init_req = false;
+
+			if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+				port_base = __cvmx_helper_cfg_pko_port_base(interface, port);
+				if (port_base == CVMX_HELPER_CFG_INVALID_VALUE)
+					init_req = true;
+			} else {
+				port_base = cvmx_helper_get_ipd_port(interface, port);
+				queue = __cvmx_helper_cfg_pko_queue_base(port_base);
+				if (queue == CVMX_HELPER_CFG_INVALID_VALUE)
+					init_req = true;
+			}
+
+			if (init_req) {
+				rv = cvmx_pko_alloc_iport_and_queues(interface,
+								     port, 1, 1);
+				if (rv < 0) {
+					cvmx_dprintf("cvm_pko_alloc_iport_and_queues failed.\n");
+					return rv;
+				}
+			}
+		}
+	}
+
+	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+		cvmx_helper_cfg_init_pko_port_map();
+		__cvmx_helper_cfg_init_ipd2pko_cache();
+	}
+
+	if (dbg) {
+		cvmx_helper_cfg_show_cfg();
+		cvmx_pko_queue_show();
+	}
+	return rv;
+#endif
+}
+EXPORT_SYMBOL(__cvmx_helper_init_port_config_data);
+
+/**
+ * @INTERNAL
+ * Override default autonegotiation for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param enable	true to enable autonegotiation, false to force full
+ *			duplex, full speed.
+ */
+void cvmx_helper_set_port_autonegotiation(int xiface, int index, bool enable)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].disable_an = !enable;
+}
+EXPORT_SYMBOL(cvmx_helper_set_port_autonegotiation);
+
+/**
+ * @INTERNAL
+ * Returns if autonegotiation is enabled or not.
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return 0 if autonegotiation is disabled, 1 if enabled.
+ */
+bool cvmx_helper_get_port_autonegotiation(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return !cvmx_cfg_port[xi.node][xi.interface][index].disable_an;
+}
+
+/**
+ * @INTERNAL
+ * Override default forward error correction for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param enable	true to enable fec, false to disable it
+ */
+void cvmx_helper_set_port_fec(int xiface, int index, bool enable)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].enable_fec = enable;
+}
+
+/**
+ * @INTERNAL
+ * Returns if forward error correction is enabled or not.
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return false if fec is disabled, true if enabled.
+ */
+bool cvmx_helper_get_port_fec(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	return cvmx_cfg_port[xi.node][xi.interface][index].enable_fec;
+}
+
+/**
+ * @INTERNAL
+ * Sets the PHY info data structure
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param[in] phy_info	phy information data structure pointer
+ */
+void cvmx_helper_set_port_phy_info(int xiface, int index,
+				   struct cvmx_phy_info *phy_info)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	if (!port_cfg_data_initialized)
+		cvmx_init_port_cfg();
+	cvmx_cfg_port[xi.node][xi.interface][index].phy_info = phy_info;
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index e07d8f15efba..c186b7558cd9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -40,6 +40,8 @@
 #include <asm/octeon/cvmx-gmxx-defs.h>
 #include <asm/octeon/cvmx-pcsx-defs.h>
 #include <asm/octeon/cvmx-pcsxx-defs.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+
 
 /**
  * Perform initialization required only once for an SGMII port.
@@ -68,6 +70,17 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 	 */
 	pcs_misc_ctl_reg.u64 =
 	    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+
+	/* Adjust the MAC mode if requested by device tree */
+	pcs_misc_ctl_reg.s.mac_phy =
+		cvmx_helper_get_mac_phy_mode(interface, index);
+	pcs_misc_ctl_reg.s.mode =
+		cvmx_helper_get_1000x_mode(interface, index);
+	cvmx_write_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface),
+		       pcs_misc_ctl_reg.u64);
+
+
+
 	pcsx_linkx_timer_count_reg.u64 =
 	    cvmx_read_csr(CVMX_PCSX_LINKX_TIMER_COUNT_REG(index, interface));
 	if (pcs_misc_ctl_reg.s.mode) {
@@ -94,6 +107,7 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 	if (pcs_misc_ctl_reg.s.mode) {
 		/* 1000BASE-X */
 		union cvmx_pcsx_anx_adv_reg pcsx_anx_adv_reg;
+		pr_err("__cvmx_helper_sgmii_hardware_init_one_time, interface %d/%d, protocol 1000BASE-X\n", interface, index);
 		pcsx_anx_adv_reg.u64 =
 		    cvmx_read_csr(CVMX_PCSX_ANX_ADV_REG(index, interface));
 		pcsx_anx_adv_reg.s.rem_flt = 0;
@@ -103,12 +117,10 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 		cvmx_write_csr(CVMX_PCSX_ANX_ADV_REG(index, interface),
 			       pcsx_anx_adv_reg.u64);
 	} else {
-		union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
-		pcsx_miscx_ctl_reg.u64 =
-		    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-		if (pcsx_miscx_ctl_reg.s.mac_phy) {
+		if (pcs_misc_ctl_reg.s.mac_phy) {
 			/* PHY Mode */
 			union cvmx_pcsx_sgmx_an_adv_reg pcsx_sgmx_an_adv_reg;
+		  pr_err("__cvmx_helper_sgmii_hardware_init_one_time, interface %d/%d, protocol SGMII, PHY mode\n", interface, index);
 			pcsx_sgmx_an_adv_reg.u64 =
 			    cvmx_read_csr(CVMX_PCSX_SGMX_AN_ADV_REG
 					  (index, interface));
@@ -120,6 +132,7 @@ static int __cvmx_helper_sgmii_hardware_init_one_time(int interface, int index)
 				       pcsx_sgmx_an_adv_reg.u64);
 		} else {
 			/* MAC Mode - Nothing to do */
+		  pr_err("__cvmx_helper_sgmii_hardware_init_one_time, interface %d/%d, protocol SGMII, MAC mode\n", interface, index);
 		}
 	}
 	return 0;
@@ -424,71 +437,17 @@ union cvmx_helper_link_info __cvmx_helper_sgmii_link_get(int ipd_port)
 
 	pcs_misc_ctl_reg.u64 =
 	    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-	if (pcs_misc_ctl_reg.s.mode) {
-		/* 1000BASE-X */
-		/* FIXME */
+	if (pcs_misc_ctl_reg.s.mac_phy ||
+	    cvmx_helper_get_port_force_link_up(interface, index)) {
+		/* PHY Mode */
+		/* Note that this also works for 1000base-X mode */
+		result.s.speed = 1000;
+		result.s.full_duplex = 1;
+		result.s.link_up = 1;
+		return result;
 	} else {
-		union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
-		pcsx_miscx_ctl_reg.u64 =
-		    cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-		if (pcsx_miscx_ctl_reg.s.mac_phy) {
-			/* PHY Mode */
-			union cvmx_pcsx_mrx_status_reg pcsx_mrx_status_reg;
-			union cvmx_pcsx_anx_results_reg pcsx_anx_results_reg;
-
-			/*
-			 * Don't bother continuing if the SERTES low
-			 * level link is down
-			 */
-			pcsx_mrx_status_reg.u64 =
-			    cvmx_read_csr(CVMX_PCSX_MRX_STATUS_REG
-					  (index, interface));
-			if (pcsx_mrx_status_reg.s.lnk_st == 0) {
-				if (__cvmx_helper_sgmii_hardware_init_link
-				    (interface, index) != 0)
-					return result;
-			}
-
-			/* Read the autoneg results */
-			pcsx_anx_results_reg.u64 =
-			    cvmx_read_csr(CVMX_PCSX_ANX_RESULTS_REG
-					  (index, interface));
-			if (pcsx_anx_results_reg.s.an_cpt) {
-				/*
-				 * Auto negotiation is complete. Set
-				 * status accordingly.
-				 */
-				result.s.full_duplex =
-				    pcsx_anx_results_reg.s.dup;
-				result.s.link_up =
-				    pcsx_anx_results_reg.s.link_ok;
-				switch (pcsx_anx_results_reg.s.spd) {
-				case 0:
-					result.s.speed = 10;
-					break;
-				case 1:
-					result.s.speed = 100;
-					break;
-				case 2:
-					result.s.speed = 1000;
-					break;
-				default:
-					result.s.speed = 0;
-					result.s.link_up = 0;
-					break;
-				}
-			} else {
-				/*
-				 * Auto negotiation isn't
-				 * complete. Return link down.
-				 */
-				result.s.speed = 0;
-				result.s.link_up = 0;
-			}
-		} else {	/* MAC Mode */
-
-			result = __cvmx_helper_board_link_get(ipd_port);
-		}
+		/* MAC Mode */
+		result = __cvmx_helper_board_link_get(ipd_port);
 	}
 	return result;
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
new file mode 100644
index 000000000000..02c0968aa59c
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -0,0 +1,793 @@
+/***********************license start***************
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Helper Functions for the Configuration Framework
+ *
+ * OCTEON_CN68XX introduces a flexible hw interface configuration
+ * scheme. To cope with this change and the requirements of
+ * configurability for other system resources, e.g., IPD/PIP pknd and
+ * PKO ports and queues, a configuration framework for the SDK is
+ * designed. It has two goals: first to recognize and establish the
+ * default configuration and, second, to allow the user to define key
+ * parameters in a high-level language.
+ *
+ * The helper functions query the QLM setup to help achieving the
+ * first goal.
+ *
+ * The second goal is accomplished by generating
+ * cvmx_helper_cfg_init() from a high-level lanaguage.
+ *
+ * <hr>$Revision: 0 $<hr>
+ */
+
+#ifndef __CVMX_HELPER_CFG_H__
+#define __CVMX_HELPER_CFG_H__
+
+#include <asm/octeon/cvmx-helper-util.h>
+
+#define CVMX_HELPER_CFG_MAX_PKO_PORT		128
+#define CVMX_HELPER_CFG_MAX_PIP_BPID       	64
+#define CVMX_HELPER_CFG_MAX_PIP_PKND       	64
+#define CVMX_HELPER_CFG_MAX_PKO_QUEUES     	256
+#define CVMX_HELPER_CFG_MAX_PORT_PER_IFACE 	256
+
+#define CVMX_HELPER_MAX_IFACE              11
+
+#define CVMX_HELPER_CFG_INVALID_VALUE		-1	/* The default return
+							 * value upon failure
+							 */
+
+#define cvmx_helper_cfg_assert(cond)					\
+	do {								\
+	    if (!(cond))						\
+	    {								\
+	        cvmx_dprintf("cvmx_helper_cfg_assert (%s) at %s:%d\n",	\
+		    #cond, __FILE__, __LINE__);				\
+	    }								\
+	} while (0)
+
+extern int cvmx_npi_max_pknds;
+
+/*
+ * Config Options
+ *
+ * These options have to be set via cvmx_helper_cfg_opt_set() before calling the
+ * routines that set up the hw. These routines process the options and set them
+ * correctly to take effect at runtime.
+ */
+enum cvmx_helper_cfg_option {
+	CVMX_HELPER_CFG_OPT_USE_DWB,	/*
+					 * Global option to control if
+					 * the SDK configures units (DMA,
+					 * SSO, and PKO) to send don't
+					 * write back (DWB) requests for
+					 * freed buffers. Set to 1/0 to
+					 * enable/disable DWB.
+					 *
+					 * For programs that fit inside
+					 * L2, sending DWB just causes
+					 * more L2 operations without
+					 * benefit.
+					 */
+
+	CVMX_HELPER_CFG_OPT_MAX
+};
+typedef enum cvmx_helper_cfg_option cvmx_helper_cfg_option_t;
+
+struct cvmx_phy_info;
+struct cvmx_fdt_sfp_info;
+struct cvmx_vsc7224_chan;
+
+/*
+ * Per physical port
+ * Note: This struct is passed between linux and SE apps.
+ */
+struct cvmx_cfg_port_param {
+	int port_fdt_node;		/** Node offset in FDT of node */
+	int phy_fdt_node;		/** Node offset in FDT of PHY */
+	struct cvmx_phy_info *phy_info;	/** Data structure with PHY information */
+	int8_t ccpp_pknd;
+	int8_t ccpp_bpid;
+	int8_t ccpp_pko_port_base;
+	int8_t ccpp_pko_num_ports;
+	uint8_t agl_rx_clk_skew;	/** AGL rx clock skew setting (default 0) */
+	uint8_t rgmii_tx_clk_delay;	/** RGMII TX clock delay value if not bypassed */
+	bool valid:1;			/** 1 = port valid, 0 = invalid */
+	bool sgmii_phy_mode:1;		/** 1 = port in PHY mode, 0 = MAC mode */
+	bool sgmii_1000x_mode:1;	/** 1 = 1000Base-X mode, 0 = SGMII mode */
+	bool agl_rx_clk_delay_bypass:1;	/** 1 = use rx clock delay bypass for AGL mode */
+	bool force_link_up:1;		/** Ignore PHY and always report link up */
+	bool disable_an:1;		/** true to disable autonegotiation */
+	bool link_down_pwr_dn:1;	/** Power PCS off when link is down */
+	bool phy_present:1;		/** true if PHY is present */
+	bool tx_clk_delay_bypass:1;	/** True to bypass the TX clock delay */
+	bool enable_fec:1;		/** True to enable FEC for 10/40G links */
+	uint8_t agl_refclk_sel;		/** RGMII refclk select to use */
+	/** Set if local (non-PHY) LEDs are used */
+	struct cvmx_phy_gpio_leds *gpio_leds;
+	struct cvmx_fdt_sfp_info *sfp_info;	/** SFP+/QSFP info for port */
+	/** Offset of SFP/SFP+/QSFP slot in device tree */
+	int sfp_of_offset;
+	/** Microsemi VSC7224 channel info data structure */
+	struct cvmx_vsc7224_chan *vsc7224_chan;
+};
+
+/*
+ * Per pko_port
+ */
+struct cvmx_cfg_pko_port_param {
+	int16_t ccppp_queue_base;
+	int16_t ccppp_num_queues;
+};
+
+/*
+ * A map from pko_port to
+ *     interface,
+ *     index, and
+ *     pko engine id
+ */
+struct cvmx_cfg_pko_port_map {
+	int16_t ccppl_interface;
+	int16_t ccppl_index;
+	int16_t ccppl_eid;
+};
+
+/*
+ * This is for looking up pko_base_port and pko_nport for ipd_port
+ */
+struct cvmx_cfg_pko_port_pair {
+	int8_t ccppp_base_port;
+	int8_t ccppp_nports;
+};
+
+typedef union cvmx_user_static_pko_queue_config
+{
+	struct
+	{
+		struct pko_queues_cfg {
+			unsigned
+				queues_per_port:5,
+				qos_enable:1,
+				pfc_enable:1;
+		} pko_cfg_iface[6];
+		struct pko_queues_cfg pko_cfg_loop;
+		struct pko_queues_cfg pko_cfg_npi;
+	} pknd;
+	struct
+	{
+		uint8_t pko_ports_per_interface[5];
+		uint8_t pko_queues_per_port_interface[5];
+		uint8_t pko_queues_per_port_loop;
+		uint8_t pko_queues_per_port_pci;
+		uint8_t pko_queues_per_port_srio[4];
+	} non_pknd;
+} cvmx_user_static_pko_queue_config_t;
+
+extern cvmx_user_static_pko_queue_config_t __cvmx_pko_queue_static_config;
+extern struct cvmx_cfg_pko_port_map cvmx_cfg_pko_port_map[CVMX_HELPER_CFG_MAX_PKO_PORT];
+extern struct cvmx_cfg_port_param cvmx_cfg_port [CVMX_MAX_NODES][CVMX_HELPER_MAX_IFACE][CVMX_HELPER_CFG_MAX_PORT_PER_IFACE];
+extern struct cvmx_cfg_pko_port_param cvmx_pko_queue_table[];
+extern int cvmx_enable_helper_flag;
+/*
+ * @INTERNAL
+ * Return configured pknd for the port
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ * @return the pknd
+ */
+extern int __cvmx_helper_cfg_pknd(int interface, int index);
+
+/*
+ * @INTERNAL
+ * Return the configured bpid for the port
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ * @return the bpid
+ */
+extern int __cvmx_helper_cfg_bpid(int interface, int index);
+
+/**
+ * @INTERNAL
+ * Return the configured pko_port base for the port
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ * @return the pko_port base
+ */
+extern int __cvmx_helper_cfg_pko_port_base(int interface, int index);
+
+/*
+ * @INTERNAL
+ * Return the configured number of pko_ports for the port
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ * @return the number of pko_ports
+ */
+extern int __cvmx_helper_cfg_pko_port_num(int interface, int index);
+
+/*
+ * @INTERNAL
+ * Return the configured pko_queue base for the pko_port
+ *
+ * @param pko_port
+ * @return the pko_queue base
+ */
+extern int __cvmx_helper_cfg_pko_queue_base(int pko_port);
+
+/*
+ * @INTERNAL
+ * Return the configured number of pko_queues for the pko_port
+ *
+ * @param pko_port
+ * @return the number of pko_queues
+ */
+extern int __cvmx_helper_cfg_pko_queue_num(int pko_port);
+
+/*
+ * @INTERNAL
+ * Return the interface the pko_port is configured for
+ *
+ * @param pko_port
+ * @return the interface for the pko_port
+ */
+extern int __cvmx_helper_cfg_pko_port_interface(int pko_port);
+
+/*
+ * @INTERNAL
+ * Return the index of the port the pko_port is configured for
+ *
+ * @param pko_port
+ * @return the index of the port
+ */
+extern int __cvmx_helper_cfg_pko_port_index(int pko_port);
+
+/*
+ * @INTERNAL
+ * Return the pko_eid of the pko_port
+ *
+ * @param pko_port
+ * @return the pko_eid
+ */
+extern int __cvmx_helper_cfg_pko_port_eid(int pko_port);
+
+/*
+ * @INTERNAL
+ * Return the max# of pko queues allocated.
+ *
+ * @return the max# of pko queues
+ *
+ * Note: there might be holes in the queue space depending on user
+ * configuration. The function returns the highest queue's index in
+ * use.
+ */
+extern int __cvmx_helper_cfg_pko_max_queue(void);
+
+/*
+ * @INTERNAL
+ * Return the max# of PKO DMA engines allocated.
+ *
+ * @return the max# of DMA engines
+ *
+ * NOTE: the DMA engines are allocated contiguously and starting from
+ * 0.
+ */
+extern int __cvmx_helper_cfg_pko_max_engine(void);
+
+/*
+ * Get the value set for the config option ``opt''.
+ *
+ * @param opt is the config option.
+ * @return the value set for the option
+ *
+ * LR: only used for DWB in NPI, POW, PKO1
+ */
+extern uint64_t cvmx_helper_cfg_opt_get(cvmx_helper_cfg_option_t opt);
+
+/*
+ * Set the value for a config option.
+ *
+ * @param opt is the config option.
+ * @param val is the value to set for the opt.
+ * @return 0 for success and -1 on error
+ *
+ * Note an option here is a config-time parameter and this means that
+ * it has to be set before calling the corresponding setup functions
+ * that actually sets the option in hw.
+ *
+ * LR: Not used.
+ */
+extern int cvmx_helper_cfg_opt_set(cvmx_helper_cfg_option_t opt, uint64_t val);
+
+/*
+ * Retrieve the pko_port base given ipd_port.
+ *
+ * @param ipd_port is the IPD eport
+ * @return the corresponding PKO port base for the physical port
+ * represented by the IPD eport or CVMX_HELPER_CFG_INVALID_VALUE.
+ */
+extern int cvmx_helper_cfg_ipd2pko_port_base(int ipd_port);
+
+/*
+ * Retrieve the number of pko_ports given ipd_port.
+ *
+ * @param ipd_port is the IPD eport
+ * @return the corresponding number of PKO ports for the physical port
+ *  represented by IPD eport or CVMX_HELPER_CFG_INVALID_VALUE.
+ */
+extern int cvmx_helper_cfg_ipd2pko_port_num(int ipd_port);
+
+/*
+ * @INTERNAL
+ * The init function
+ *
+ * @param node
+ * @return 0 for success.
+ *
+ * Note: this function is meant to be called to set the ``configured
+ * parameters,'' e.g., pknd, bpid, etc. and therefore should be before
+ * any of the corresponding cvmx_helper_cfg_xxxx() functions are
+ * called.
+ */
+extern int __cvmx_helper_init_port_config_data(int node);
+
+/*
+ * @INTERNAL
+ * The local init function
+ *
+ * @param none
+ * @return 0 for success.
+ *
+ * Note: this function is meant to be called to set the ``configured
+ * parameters locally,'' e.g., pknd, bpid, etc. and therefore should be before
+ * any of the corresponding cvmx_helper_cfg_xxxx() functions are
+ * called.
+ */
+extern int __cvmx_helper_init_port_config_data_local(void);
+
+/*
+ * Set the frame max size and jabber size to 65535.
+ *
+ */
+extern void cvmx_helper_cfg_set_jabber_and_frame_max(void);
+
+/*
+ * Enable storing short packets only in the WQE.
+ */
+extern void cvmx_helper_cfg_store_short_packets_in_wqe(void);
+
+/*
+ * Allocated a block of internal ports and queues for the specified
+ * interface/port
+ *
+ * @param  interface  the interface for which the internal ports and queues
+ *                    are requested
+ * @param  port       the index of the port within in the interface for which
+                      the internal ports and queues are requested.
+ * @param  pot_count  the number of internal ports requested
+ * @param  queue_cnt  the number of queues requested for each of the internal
+ *                    port. This call will allocate a total of
+ *		      (port_cnt * queue_cnt) queues
+ *
+ * @return  0 on success
+ *         -1 on failure
+ *
+ * LR: Called ONLY from comfig-parse!
+ */
+ int cvmx_pko_alloc_iport_and_queues(int interface, int port, int port_cnt,
+				     int queue_cnt);
+
+/*
+ * Free the queues that are associated with the specified port
+ *
+ * @param  port   the internal port for which the queues are freed.
+ *
+ * @return  0 on success
+ *         -1 on failure
+ */
+int cvmx_pko_queue_free(uint64_t port);
+
+/*
+ * Initializes the pko queue range data structure.
+ * @return  0 on success
+ *         -1 on failure
+ */
+int init_cvmx_pko_que_range(void);
+
+/*
+ * Frees up all the allocated ques.
+ */
+void cvmx_pko_queue_free_all(void);
+
+/**
+ * Returns if port is valid for a given interface
+ *
+ * @param xiface     interface to check
+ * @param index      port index in the interface
+ *
+ * @return status of the port present or not.
+ */
+int cvmx_helper_is_port_valid(int xiface, int index);
+
+/**
+ * Set whether or not a port is valid
+ *
+ * @param interface interface to set
+ * @param index     port index to set
+ * @param valid     set 0 to make port invalid, 1 for valid
+ */
+void cvmx_helper_set_port_valid(int interface, int index, bool valid);
+
+/**
+ * @INTERNAL
+ * Return if port is in PHY mode
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ *
+ * @return 1 if port is in PHY mode, 0 if port is in MAC mode
+ */
+extern bool cvmx_helper_get_mac_phy_mode(int interface, int index);
+extern void cvmx_helper_set_mac_phy_mode(int interface, int index, bool valid);
+
+/**
+ * @INTERNAL
+ * Return if port is in 1000Base X mode
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ *
+ * @return 1 if port is in 1000Base X mode, 0 if port is in SGMII mode
+ */
+extern bool cvmx_helper_get_1000x_mode(int interface, int index);
+extern void cvmx_helper_set_1000x_mode(int interface, int index, bool valid);
+
+/**
+ * @INTERNAL
+ * Return if an AGL port should bypass the RX clock delay
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ */
+extern bool cvmx_helper_get_agl_rx_clock_delay_bypass(int interface, int index);
+extern void cvmx_helper_set_agl_rx_clock_delay_bypass(int interface, int index,
+						      bool valid);
+
+/**
+ * @INTERNAL
+ * Forces a link to always return that it is up ignoring the PHY (if present)
+ *
+ * @param interface the interface number
+ * @param index the port's index
+ */
+extern bool cvmx_helper_get_port_force_link_up(int interface, int index);
+extern void cvmx_helper_set_port_force_link_up(int interface, int index,
+					       bool value);
+
+/**
+ * @INTERNAL
+ * Return true if PHY is present to the passed xiface
+ *
+ * @param xiface the interface number
+ * @param index the port's index
+ */
+extern bool cvmx_helper_get_port_phy_present(int xiface, int index);
+extern void cvmx_helper_set_port_phy_present(int xiface, int index,
+					     bool value);
+
+/**
+ * @INTERNAL
+ * Return the AGL port rx clock skew, only used
+ * if agl_rx_clock_delay_bypass is set.
+ *
+ * @param interface the interface number
+ * @param index the port's index number
+ */
+extern uint8_t cvmx_helper_get_agl_rx_clock_skew(int interface, int index);
+extern void cvmx_helper_set_agl_rx_clock_skew(int interface, int index,
+					      uint8_t value);
+extern uint8_t cvmx_helper_get_agl_refclk_sel(int interface, int index);
+extern void cvmx_helper_set_agl_refclk_sel(int interface, int index,
+					      uint8_t value);
+
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+/**
+ * @INTERNAL
+ * Store the FDT node offset in the device tree of a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param node_offset	node offset to store
+ */
+extern void cvmx_helper_set_port_fdt_node_offset(int xiface, int index,
+						 int node_offset);
+
+/**
+ * @INTERNAL
+ * Return the FDT node offset in the device tree of a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @return		node offset of port or -1 if invalid
+ */
+extern int cvmx_helper_get_port_fdt_node_offset(int xiface, int index);
+
+/**
+ * @INTERNAL
+ * Store the FDT node offset in the device tree of a phy
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param node_offset	node offset to store
+ */
+extern void cvmx_helper_set_phy_fdt_node_offset(int xiface, int index,
+						int node_offset);
+
+/**
+ * @INTERNAL
+ * Return the FDT node offset in the device tree of a phy
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @return		node offset of phy or -1 if invalid
+ */
+extern int cvmx_helper_get_phy_fdt_node_offset(int xiface, int index);
+#endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
+
+/**
+ * @INTERNAL
+ * Override default autonegotiation for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param enable	true to enable autonegotiation, false to force full
+ *			duplex, full speed.
+ */
+extern void cvmx_helper_set_port_autonegotiation(int xiface, int index,
+						 bool enable);
+
+/**
+ * @INTERNAL
+ * Returns if autonegotiation is enabled or not.
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return 0 if autonegotiation is disabled, 1 if enabled.
+ */
+extern bool cvmx_helper_get_port_autonegotiation(int xiface, int index);
+
+/**
+ * @INTERNAL
+ * Returns if forward error correction is enabled or not.
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return 0 if fec is disabled, 1 if enabled.
+ */
+extern bool cvmx_helper_get_port_fec(int xiface, int index);
+
+/**
+ * @INTERNAL
+ * Override default forward error correction for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param enable	true to enable fec, false to disable.
+ */
+extern void cvmx_helper_set_port_fec(int xiface, int index, bool enable);
+
+/**
+ * @INTERNAL
+ * Sets the PHY info data structure
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param[in] phy_info	phy information data structure pointer
+ */
+extern void cvmx_helper_set_port_phy_info(int xiface, int index,
+					  struct cvmx_phy_info *phy_info);
+/**
+ * @INTERNAL
+ * Returns the PHY information data structure for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return pointer to PHY information data structure or NULL if not set
+ */
+extern struct cvmx_phy_info *cvmx_helper_get_port_phy_info(int xiface, int index);
+
+/**
+ * @INTERNAL
+ * Returns a pointer to the PHY LED configuration (if local GPIOs drive them)
+ *
+ * @param xiface	node and interface
+ * @param index		portindex
+ *
+ * @return pointer to the PHY LED information data structure or NULL if not
+ *	   present
+ */
+extern struct cvmx_phy_gpio_leds *cvmx_helper_get_port_phy_leds(int xiface,
+								int index);
+
+/**
+ * @INTERNAL
+ * Sets a pointer to the PHY LED configuration (if local GPIOs drive them)
+ *
+ * @param xiface	node and interface
+ * @param index		portindex
+ * @param leds		pointer to led data structure
+ */
+extern void cvmx_helper_set_port_phy_leds(int xiface, int index,
+					  struct cvmx_phy_gpio_leds *leds);
+
+/**
+ * @INTERNAL
+ * Disables RGMII TX clock bypass and sets delay value
+ *
+ * @param xiface	node and interface
+ * @param index		portindex
+ * @param bypass	Set true to enable the clock bypass and false
+ *			to sync clock and data synchronously.
+ *			Default is false.
+ * @param clk_delay	Delay value to skew TXC from TXD
+ */
+void cvmx_helper_cfg_set_rgmii_tx_clk_delay( int xiface, int index,
+					     bool bypass, int clk_delay);
+
+/**
+ * @INTERNAL
+ * Gets RGMII TX clock bypass and delay value
+ *
+ * @param xiface	node and interface
+ * @param index		portindex
+ * @param bypass	Set true to enable the clock bypass and false
+ *			to sync clock and data synchronously.
+ *			Default is false.
+ * @param clk_delay	Delay value to skew TXC from TXD, default is 0.
+ */
+void cvmx_helper_cfg_get_rgmii_tx_clk_delay(int xiface, int index,
+					    bool *bypass,
+					    int *clk_delay);
+
+/**
+ * @INTERNAL
+ * Retrieve the SFP node offset in the device tree
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return offset in device tree or -1 if error or not defined.
+ */
+int cvmx_helper_cfg_get_sfp_fdt_offset(int xiface, int index);
+
+/**
+ * Search for a port based on its FDT node offset
+ *
+ * @param	of_offset	Node offset of port to search for
+ *
+ * @return	ipd_port or -1 if not found
+ */
+int cvmx_helper_cfg_get_ipd_port_by_fdt_node_offset(int of_offset);
+
+/**
+ * @INTERNAL
+ * Sets the SFP node offset
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param sfp_of_offset	Offset of SFP node in device tree
+ */
+void cvmx_helper_cfg_set_sfp_fdt_offset(int xiface, int index,
+					int sfp_of_offset);
+
+/**
+ * Search for a port based on its FDT node offset
+ *
+ * @param	of_offset	Node offset of port to search for
+ * @param[out]	xiface		xinterface of match
+ * @param[out]	index		port index of match
+ *
+ * @return	0 if found, -1 if not found
+ */
+int cvmx_helper_cfg_get_xiface_index_by_fdt_node_offset(int of_offset,
+							int *xiface, int *index);
+
+/**
+ * Get data structure defining the Microsemi VSC7224 channel info
+ * or NULL if not present
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return pointer to vsc7224 data structure or NULL if not present
+ */
+struct cvmx_vsc7224_chan *cvmx_helper_cfg_get_vsc7224_chan_info(int xiface,
+								int index);
+
+/**
+ * Sets the Microsemi VSC7224 channel data structure
+ *
+ * @param	xiface	node and interface
+ * @param	index	port index
+ * @param[in]	vsc7224_info	Microsemi VSC7224 data structure
+ */
+void cvmx_helper_cfg_set_vsc7224_chan_info(int xiface, int index,
+				struct cvmx_vsc7224_chan *vsc7224_chan_info);
+
+/**
+ * Gets the SFP data associated with a port
+ *
+ * @param	xiface	node and interface
+ * @param	index	port index
+ *
+ * @return	pointer to SFP data structure or NULL if none
+ */
+struct cvmx_fdt_sfp_info *cvmx_helper_cfg_get_sfp_info(int xiface, int index);
+
+/**
+ * Sets the SFP data associated with a port
+ *
+ * @param	xiface		node and interface
+ * @param	index		port index
+ * @param[in]	sfp_info	port SFP data or NULL for none
+ */
+void cvmx_helper_cfg_set_sfp_info(int xiface, int index,
+				  struct cvmx_fdt_sfp_info *sfp_info);
+
+/*
+ * Initializes cvmx with user specified config info.
+ */
+int cvmx_user_static_config(void);
+void cvmx_pko_queue_show(void);
+int cvmx_fpa_pool_init_from_cvmx_config(void);
+int __cvmx_helper_init_port_valid(void);
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+}
+/* *INDENT-ON* */
+#endif
+#endif /* __CVMX_HELPER_CFG_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-util.h b/arch/mips/include/asm/octeon/cvmx-helper-util.h
index 97b27a07cfb0..f08d0e75c85e 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-util.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-util.h
@@ -189,4 +189,37 @@ extern int cvmx_helper_get_interface_num(int ipd_port);
  */
 extern int cvmx_helper_get_interface_index_num(int ipd_port);
 
+struct cvmx_xiface {
+        int node;
+        int interface;
+};
+typedef struct cvmx_xiface cvmx_xiface_t;
+
+
+
+/**
+ * Return node and interface number from XIFACE.
+ *
+ * @param xiface interface with node information
+ *
+ * @return struct that contains node and interface number.
+ */
+static inline struct cvmx_xiface cvmx_helper_xiface_to_node_interface(int xiface)
+{
+        cvmx_xiface_t interface_node;
+        /*
+         * If the majic number 0xde0000 is not present in the
+         * interface, then assume it is node 0.
+         */
+
+        if (((xiface >> 0x8) & 0xff) == 0xde) {
+                interface_node.node = (xiface >> 16) & CVMX_NODE_MASK;
+                interface_node.interface = xiface & 0xff;
+        } else {
+                interface_node.node = cvmx_get_node_num();
+                interface_node.interface = xiface & 0xff;
+        }
+        return interface_node;
+}
+
 #endif /* __CVMX_HELPER_H__ */
diff --git a/drivers/staging/octeon/Makefile b/drivers/staging/octeon/Makefile
index 3887cf5f1e84..2e81ed33009d 100644
--- a/drivers/staging/octeon/Makefile
+++ b/drivers/staging/octeon/Makefile
@@ -9,6 +9,8 @@
 
 obj-${CONFIG_OCTEON_ETHERNET} :=  octeon-ethernet.o
 
+ccflags-y += -DDEBUG
+
 octeon-ethernet-y := ethernet.o
 octeon-ethernet-y += ethernet-mdio.o
 octeon-ethernet-y += ethernet-mem.o
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index 12bcc5632e61..c7452e013aca 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -487,7 +487,13 @@ int cvm_oct_common_open(struct net_device *dev,
 			netif_carrier_off(dev);
 		cvm_oct_adjust_link(dev);
 	} else {
+#if 0
 		link_info = cvmx_helper_link_get(priv->port);
+#else
+    link_info.s.link_up = 1;
+    link_info.s.full_duplex = 1;
+    link_info.s.speed = 1000;
+#endif
 		if (!link_info.s.link_up)
 			netif_carrier_off(dev);
 		priv->poll = link_poll;
@@ -502,7 +508,13 @@ void cvm_oct_link_poll(struct net_device *dev)
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	union cvmx_helper_link_info link_info;
 
+#if 0
 	link_info = cvmx_helper_link_get(priv->port);
+#endif
+  link_info.s.link_up = 1;
+  link_info.s.full_duplex = 1;
+  link_info.s.speed = 1000;
+
 	if (link_info.u64 == priv->link_info)
 		return;
 
@@ -677,6 +689,67 @@ static void cvm_set_rgmii_delay(struct octeon_ethernet *priv, int iface,
 		priv->phy_mode = PHY_INTERFACE_MODE_RGMII;
 }
 
+static int cvm_oct_get_port_status(struct device_node *pip)
+{
+	int i, j;
+	int num_interfaces = cvmx_helper_get_number_of_interfaces();
+
+  pr_info("cvm_oct_get_port_status running over %d interfaces\n", num_interfaces);
+	for (i = 0; i < num_interfaces; i++) {
+		int num_ports = cvmx_helper_ports_on_interface(i);
+		int mode = cvmx_helper_interface_get_mode(i);
+		struct device_node *port_node;
+
+    pr_info("cvm_oct_get_port_status interface %d, #ports = %d\n", i, num_ports);
+		for (j = 0; j < num_ports; j++) {
+			port_node = cvm_oct_node_for_port(pip, i, j);
+      pr_info("cvm_oct_get_port_status %d/%d, mode = %d, port_node = %d\n", i, j, mode, !!port_node);
+			switch (mode) {
+			case CVMX_HELPER_INTERFACE_MODE_RGMII:
+			case CVMX_HELPER_INTERFACE_MODE_GMII:
+			case CVMX_HELPER_INTERFACE_MODE_XAUI:
+			case CVMX_HELPER_INTERFACE_MODE_SPI:
+				if (port_node)
+					cvmx_helper_set_port_valid(i, j, true);
+				else
+					cvmx_helper_set_port_valid(i, j, false);
+				cvmx_helper_set_mac_phy_mode(i, j, false);
+				cvmx_helper_set_1000x_mode(i, j, false);
+				break;
+			case CVMX_HELPER_INTERFACE_MODE_SGMII:
+			{
+				if (port_node != NULL)
+					cvmx_helper_set_port_valid(i, j, true);
+				else
+					cvmx_helper_set_port_valid(i, j, false);
+				cvmx_helper_set_mac_phy_mode(i, j, false);
+				cvmx_helper_set_1000x_mode(i, j, false);
+				if (port_node) {
+					if (of_get_property(port_node,
+					     "cavium,sgmii-mac-phy-mode", NULL) != NULL) {
+            pr_info("sgmii-mac-phy-mode found, setting..\n");
+						cvmx_helper_set_mac_phy_mode(i, j, true);
+          }
+					if (of_get_property(port_node,
+					    "cavium,sgmii-mac-1000x-mode", NULL)
+					    != NULL) {
+            pr_info("sgmii-mac-1000x-mode found setting..\n");
+						cvmx_helper_set_1000x_mode(i, j, true);
+          }
+				}
+				break;
+			}
+			default:
+				cvmx_helper_set_port_valid(i, j, true);
+				cvmx_helper_set_mac_phy_mode(i, j, false);
+				cvmx_helper_set_1000x_mode(i, j, false);
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
 static int cvm_oct_probe(struct platform_device *pdev)
 {
 	int num_interfaces;
@@ -701,6 +774,8 @@ static int cvm_oct_probe(struct platform_device *pdev)
 
 	cvmx_helper_initialize_packet_io_global();
 
+	cvm_oct_get_port_status(pip);
+
 	if (receive_group_order) {
 		if (receive_group_order > 4)
 			receive_group_order = 4;
diff --git a/drivers/staging/octeon/octeon-ethernet.h b/drivers/staging/octeon/octeon-ethernet.h
index a6140705706f..d7dc1d37b117 100644
--- a/drivers/staging/octeon/octeon-ethernet.h
+++ b/drivers/staging/octeon/octeon-ethernet.h
@@ -23,6 +23,7 @@
 #include <asm/octeon/cvmx-fau.h>
 #include <asm/octeon/cvmx-gmxx-defs.h>
 #include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-helper-util.h>
 #include <asm/octeon/cvmx-ipd.h>
 #include <asm/octeon/cvmx-ipd-defs.h>
-- 
2.41.0

